#+TITLE: Emacs Configuration
#+AUTHOR: t3mpt0n
#+OPTIONS: toc:2

* Introduction
This is the configutation to my Emacs, enjoy!

* Package Managers
** [[https://github.com/progfolio/elpaca][Elpaca]]
The package manager used for my configuration along with nix for the Emacs package itself

Requirements:
- Emacs >= 27.1
- Git

This will clone Elpaca to =user-emacs-directory/elpaca=
*** Installer
#+begin_src elisp :mkdirp yes :tangle ./early-init.el
(defvar elpaca-installer-version 0.5)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

*** Configuration
#+begin_src elisp :mkdirp yes :tangle ./early-init.el
(setq package-enable-at-startup nil)
(defvar t3mpt0n/font "FiraCode Nerd Font"
  "Font for Emacs")

(provide 'early-init)
;;early-init.el ends here
#+end_src
#+begin_src elisp :mkdirp yes :tangle ./modules/elpaca/config.el
(elpaca elpaca-use-package
   (elpaca-use-package-mode)
   (setq elpaca-use-package-by-default t
         use-package-always-ensure t))
(elpaca-wait)
#+end_src
Also, make sure that any =after-init-hook= or =emacs-startup-hook= is changed to =elpaca-after-init-hook=.

** [[https://github.com/NixOS/nix][Nix]]
Requirements:
- Nix Package Manager

My personal choice of package manager, however, *NOT* configured in elisp.
*** Setting up the emacs package itself
#+begin_src nix :tangle ./default.nix
  {
    self,
    pkgs,
    ...
  }: {
    imports = [
      ./lsp
    ];

    nixpkgs.overlays = [ (import self.inputs.emacs-overlay) ];

    environment.systemPackages = [
      (pkgs.emacsWithPackagesFromUsePackage {
        config = ./init.el;
        defaultInitFile = true;
        package = pkgs.emacs-pgtk;
        extraEmacsPackages = epkgs: with epkgs; [
          use-package # Install use-package to use in tandem w/ elpaca
          vterm # Avoid annoying 'vterm-module' error
        ];
        alwaysEnsure = true;
      })
      (pkgs.nerdfonts.override { fonts = [ "FiraCode" "Iosevka" "NerdFontsSymbolsOnly" ]; })
      pkgs.fira-code-symbols
    ];
  }
#+end_src

* User Interface
By default, Emacs looks like shit... let's fix that!
*** Some initial setup
#+begin_src elisp :tangle ./modules/UI.el
  (use-package emacs
    :elpaca nil
    :init
    (setq inhibit-startup-message t
          visible-bell t
          frame-resize-pixelwise t
          package-native-compile t)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1)
    (set-fringe-mode 10)
    (menu-bar-mode -1)
    (global-prettify-symbols-mode 1)
    :hook
    (prog-mode . menu-bar--display-line-numbers-mode-relative)
    (org-mode . menu-bar--display-line-numbers-mode-relative)
    (find-file . (lambda () (set-face-attribute 'default nil :font t3mpt0n/font :height 148))))
#+end_src

*** Ligatures
Requirements:
- Fira Code ::
  - Fira Code Symbols
  - Emacs >= 28.1
- Non-Fira Code ::
  - Emacs >= 28.1

Like every zoomer, I like my ligatures :).
#+begin_src elisp :mkdirp yes :tangle ./modules/UI.el
  (if (and (= (string-search "FiraCode" t3mpt0n/font) 0) (> emacs-major-version 28))
        (use-package fira-code-mode
          :after emacs
          :hook prog-mode
          :custom (fira-code-mode-disabled-ligatures '("www" ":" "*" "x" "&&")))
    (use-package ligature
      :after emacs
      :config
      (ligature-set-ligatures 't '("www"))
      (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                           ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                           "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                           "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                           "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                           "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                           "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                           "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                           ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                           "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                           "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                           "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                           "\\\\" "://"))
      (global-ligature-mode t)))
(defun t3mpt0n/prog-mode/customligs ()
  "Custom Ligatures for prog-mode"
  (mapc (lambda (pair) (push pair prettify-symbols-alist))
        '(
          ("defun" . #x1d453)
          ("def" . #x1d453)
          ("or" . #x2228)
          ("&&" . #x2227)
          ("and" . #x2227)
          ("in" . #x2208)
          ("true" . #x22a5)
          ("false" . #x22a4)
          ("int" . #x2124)
          ("float" . #x211d)
          ("not" . #xac)
          ("from" . #x21a6)
          ("import" . #x21a7))))
#+end_src

*** Icons
Enable icons for later.
#+begin_src elisp :mkdirp yes :tangle ./modules/UI.el
  (use-package all-the-icons)
  (use-package all-the-icons-nerd-fonts :after all-the-icons)
  (use-package nerd-icons)
  (use-package nerd-icons-completion :after nerd-icons)
  (use-package emojify
    :hook (elpaca-after-init . global-emojify-mode))
#+end_src

*** Theme
**** Modeline
I like the modeline from Spacemacs.
#+begin_src elisp :tangle ./modules/UI.el
  (use-package spaceline
    :init
    (setq powerline-default-seperator nil
          spacemacs-theme-underline-parens t))

  (use-package spaceline-all-the-icons
    :after (all-the-icons all-the-icons-nerd-fonts))
#+end_src

**** DOOM
Doom Emacs has a great collection of themes and colors my modeline.
#+begin_src elisp :tangle ./modules/UI.el
  (use-package doom-themes
    :init
    (progn
      (load-theme 'doom-tomorrow-night t)
      (enable-theme 'doom-tomorrow-night)))

  (use-package doom-modeline
    :init (doom-modeline-mode 1))
#+end_src

*** Menus
Hodgepodge of menu stuff that's worked for me so far.
#+begin_src elisp :tangle ./modules/UI.el
  (use-package counsel
    :bind (
     ("M-x" . counsel-M-x)
     ("C-x b" . counsel-ibuffer)
     ("C-x C-f" . counsel-find-file)))

  (use-package prescient
    :config (setq prescient-persist-mode t))

  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)))

  (use-package ivy-prescient
    :after counsel
    :config
    (ivy-prescient-mode 1))

  (use-package ivy-rich
    :init
    (ivy-rich-mode 1))

  (use-package vertico
    :init
    (vertico-mode))

  (use-package savehist
    :elpaca nil
    :init
    (savehist-mode))

  (use-package marginalia
    :after vertico
    :demand t
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src

*** Sway fix && Transparency
Fix emacs bugginess on Sway (for the most part).
#+begin_src elisp :mkdirp yes :tangle ./modules/UI.el
  (use-package shackle
    :demand t
    :config
    (setq frame-title-format '("%b â€” GNU Emacs [" (:eval (frame-parameter (selected-frame) 'window-id)) "]"))
    (add-to-list 'default-frame-alist '(alpha-background . 90)))

  (use-package sway
    :config
    (sway-socket-tracker-mode)
    (sway-undertaker-mode)
    (sway-x-focus-through-sway-mode))
#+end_src

* Startup
** Garbage Cleanup
Move backup files to one folder to save me writing an MLA format =.gitignore=.
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (setq backup-directory-alist '(("" . "~/.cache/emacs/"))
        backup-by-copying t
        version-control t
        delete-old-backups t
        kept-new-versions 20
        kept-old-versions 5)
#+end_src

** Custom Functions
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (defun t3mpt0n/show-and-copy-buffer-path ()
    "Show and copy the full path to the current file in the minibuffer."
    (interactive)
    ;; list-buffers-directory is the variable set in dired buffers
    (let ((file-name (or (buffer-file-name) list-buffers-directory)))
      (if file-name
          (message (kill-new file-name))
        (error "Buffer not visiting a file"))))
#+end_src

** Dashboard
I don't want to open a frame just to see an empty scratch buffer.
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (use-package dashboard
    :hook
    (elpaca-after-init . dashboard-insert-startupify-lists)
    (elpaca-after-init . dashboard-initialize)

    :config
    (dashboard-setup-startup-hook)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-items '((bookmarks . 7)
                            (agenda . 3)
                            (recents . 5))
          dashboard-banner-ascii "NIXMACS"
          dashboard-center-content t
          dashboard-set-init-info t
          dashboard-filter-agenda-entry 'dashboard-no-filter-agenda))
#+end_src

** Enable Keybindings
Useful for configuring keybindings later.
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (use-package hydra)
  (use-package which-key
    :init
    (setq which-key-side-window-location 'bottom
          which-key-sort-order #'which-key-key-order-alpha
          which-key-idle-delay 0.2
          which-key-allow-imprecise-window-fit t)
    (which-key-mode)
    :diminish
    which-key-mode)

  (use-package general
    :init
    (general-create-definer t3mpt0n/leader-keys
      :keymaps 'override
      :states '(normal visual)
      :prefix "SPC"
      :global-prefix "M-SPC")
    (winner-mode 1)

    :config
    (general-evil-setup t)
#+end_src

*** Some convinient keys
**** Use ESC and not C-g
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

**** Quits (SPC q)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "q" '(:which-key "Quits")
    "q q" '(save-buffers-kill-terminal :which-key "Save Buffers Kill Frame")
    "q 3" 'server-edit
    "q 5 0" '(delete-frame :which-key "Delete Frame")
    "q k" '(save-buffers-kill-emacs :which-key "Kill Daemon Gracefully"))
#+end_src

**** Buffers (SPC b)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "b" '(:which-key "Buffers")
    "b m" '(counsel-ibuffer :which-key "Switch to Another Buffer")
    "b c" '(clone-indirect-buffer-other-window :which-key "Clone indirect buffer other window")
    "b b" '(ibuffer-list-buffers :which-key "List Buffers in Seperate Window")
    "b B" '(ibuffer :which-key "List Buffers in Same Window")
    "b d" '(kill-current-buffer :which-key "Kill Current Buffer")
    "b D" '(kill-buffer :which-key "Choose Which Buffer to Kill")
    "b l" '(next-buffer :which-key "Next Buffer")
    "b h" '(previous-buffer :which-key "Previous Buffer"))
#+end_src

**** Window Control w/ Evil & Winner (SPC w)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "w" '(:which-key "Windows")
    "w k" '(evil-window-delete :which-key "Close window")
    "w n" '(evil-window-new :which-key "New window")
    "w s" '(evil-window-split :which-key "Horizontal split window")
    "w v" '(evil-window-vsplit :which-key "Vertical split window")
    "w q" '(evil-quit :which-key "Quit Window")
    "w h" '(evil-window-left :which-key "Window left")
    "w j" '(evil-window-down :which-key "Window down")
    "w k" '(evil-window-up :which-key "Window up")
    "w l" '(evil-window-right :which-key "Window right")
    "w w" '(evil-window-next :which-key "Goto next window")
    "w >" '(evil-window-increase-width :which-key "Increase Width")
    "w <" '(evil-window-decrease-width :which-key "Decrease Width")
    "w +" '(evil-window-increase-height :which-key "Increase Height")
    "w -" '(evil-window-decrease-height :which-key "Decrease Height")
    "w <left>"  '(winner-undo :which-key "Winner undo")
    "w <right>" '(winner-redo :which-key "Winner redo"))
#+end_src

**** Files (SPC f)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "f"   '(:which-key "File")
    "f f" '(counsel-find-file :which-key "Find File")
    "f r" '(counsel-recentf :which-key "Recent Files")
    "f s" '(save-buffer :which-key "Save File")
    "f u" '(sudo-edit-find-file :which-key "Sudo Find File")
    "f y" '(t3mpt0n/show-and-copy-buffer-path :which-key "Yank File Path")
    "f C" '(copy-file :which-key "Copy file")
    "f D" '(delete-file :which-key "Delete file")
    "f R" '(rename-file :which-key "Rename file")
    "f S" '(write-file :which-key "Save File As...")
    "f U" '(sudo-edit :which-key "Sudo Edit File")
    "f b" '(byte-compile-file :which-key "Byte Compile File")
    "f r" '(counsel-recentf :which "Recent Files"))
#+end_src

**** Help (SPC h)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "h" '(:which-key "Help")
    "h v" '(describe-variable :which-key "Describe Variable")
    "h k" '(describe-key :which-key "Describe Key")
    "h f" '(describe-function :which-key "Describe Function"))
#+end_src

**** Misc. (SPC {varied})
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (t3mpt0n/leader-keys
    "SPC" '(counsel-M-x :which-key "M-x")
    "R 3" '((lambda () (interactive) (load-file "/etc/nixos/emacs/init.el")) :which-key "Reload Emacs Config")))
#+end_src

** Fix Tabs and other Stuff (Lunarix Mode)
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (setq custom-tab-width 2)
  (defun disable-tabs () (setq indent-tabs-mode nil))
  (defvar untabify-this-buffer)

  (defun tab-all ()
    "Tabify current buffer"
    (tabify (point-min) (point-max)))

  (defun untab-all ()
    "Untabify current buffer, unless `untabify-this-buffer' is nil."
    (and untabify-this-buffer (untabify (point-min) (point-max))))

  (define-minor-mode lunarix-mode
    "Untabify buffer on save." nil " untab" nil
    (make-variable-buffer-local 'untabify-this-buffer)
    (setq untabify-this-buffer (not (derived-mode-p 'makefile-mode)))
    (add-hook 'before-save-hook #'untab-all))

  (setq-default electric-indent-inhibit t)
  (setq-default evil-shift-width custom-tab-width)

  (use-package whitespace
    :elpaca nil
    :init
    (global-whitespace-mode -1)

    :config
    (setq whitespace-mode '(face tabs tab-mark trailing) ;; Visualize tabs as a pipe char = "|"
          whitespace-display-mappings '((tab-mark 9 [124 9] [92 9]))))
#+end_src

** EVIL -- Vim Keybindings
As much as I adore Emacs, it's default keybindings leave me with carpal tunnel.
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (use-package undo-tree)
  (use-package evil
    :after undo-tree
    :init
    (setq evil-want-keybinding nil)
    (global-undo-tree-mode 1)

    :config
    (evil-mode 1)
    (evil-set-undo-system 'undo-tree)
    (setq undo-tree-history-directory-alist '(("." . "~/.cache/emacs/undo-tree"))))

  (use-package evil-collection
    :after evil
    :init
    (evil-collection-init)

    :config
    (setq evil-collection-mode-list '(dashboard ibuffer dired)))

  (use-package evil-tutor :after evil)
#+end_src

** SUDO && TRAMP
Enable editing files over sudo and over SSH.
#+begin_src elisp :mkdirp yes :tangle ./modules/startup.el
  (use-package sudo-edit)

  (use-package tramp
    :elpaca nil
    :init
    (setq tramp-default-method "ssh"))
#+end_src

* Org-Mode
** Initial Setup
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package org
  :elpaca nil
  :hook (org-mode . org-indent-mode)
  :config
  (setq org-directory "~/Docs/Org"
        org-agenda-files '("Agenda.org")
        org-default-notes-file (expand-file-name "Notes.org" org-directory)
        org-log-done 'time
        org-journal-dir "~/Docs/Org/Journal"
        org-journal-date-format "%B %d, %Y (%A) "
        org-journal-file-format "%d-%m-%Y.org"
        org-hide-emphasis-markers t
        org-todo-keywords
        '((sequence
           "TODO(t!)" ; Initial Creation
           "DOING(g@)" ; WIP
           "HOMEWORK(h@)" ; Homework
           "EXAM(e@)"
           "WAIT(w@)" ; Pause Task (My Choice)
           "BLOCKED(b@)" ; Pause Task (Not My Choice)
           "REVIEW(r!)" ; Inspect or Share Time
           "|" ; Remaining Close Task
           "DONE(d@)" ; Normal Completion
           "CANCELED(c@)" ; Not Going to do it
           "DUPLICATE(p@)" ; Already did it
           ))
        org-src-preserve-indentation t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0
        org-highlight-latex-and-related '(latex script entities))

  :custom
  (defun risky-local-variable-p (sym &optional _ignored) nil))

(use-package org-contrib :after org)
#+end_src

** Org Roam
Great note-taking thing.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package org-roam
  :after (org general)
  :custom
  (org-roam-directory "~/Docs/Org/Roam")
  (org-roam-completion-everywhere t)
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  :config
  (org-roam-setup)
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "o" '(:which-key "Org Mode")
    "o r" '(:which-key "Org Roam")
    "o r b" '(:which-key "Org Roam Buffer")
    "o r b t" '(org-roam-buffer-toggle :which-key "Open/Close Org Roam Buffer")
    "o r n" '(:which-key "Org Roam Node")
    "o r n f" '(org-roam-node-find :which-key "Find Org Roam Node")
    "o r n i" '(org-roam-node-insert :which-key "Insert Org Roam Node")
    "o r n I" '(org-roam-node-insert-immediate :which-key "Insert Org Roam Node No New Buffer")
    "o r u"   '(:which-key "Org Roam UI")
    "o r u o" '(org-roam-ui-open :which-key "Org Roam UI Open")))

(use-package org-roam-ui
  :after (org-roam general)
  :hook (org-roam-mode . org-roam-ui-mode)

  :config
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "o r u"   '(:which-key "Org Roam UI")
    "o r u o" '(org-roam-ui-open :which-key "Org Roam UI Open"))
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src

** Misc. Addons
*** TOC
Enable table of contents for exported Org files.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package toc-org
  :commands toc-org-enable
  :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

*** Bullets
Pretty bullets for Org files.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package org-bullets
  :after org
  :hook (org-mode . (lambda () org-bullets-mode 1)))
#+end_src

*** CDLaTeX
Get the best of both Org and LaTeX.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package cdlatex)
#+end_src

*** Org Babel TMUX
Execute Org code blocks w/ TMUX.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package ob-tmux
  ;; Install package automatically (optional)
  :ensure t
  :config
  (setq vterm-enable-manipulate-selection-data-by-osc52 t)
  :custom
  (org-babel-default-header-args:tmux
   '((:results . "silent")                  ;
     (:session . "default")                 ; The default tmux session to send code to
     (:socket  . nil)))                     ; The default tmux socket to communicate with
  ;; The tmux sessions are prefixed with the following string.
  ;; You can customize this if you like.
  (org-babel-tmux-session-prefix "ob-")
  ;; The terminal that will be used.
  ;; You can also customize the options passed to the terminal.
  ;; The default terminal is "gnome-terminal" with options "--".
  (org-babel-tmux-terminal (concat user-emacs-directory "ob-tmux-defterm.sh"))
  (org-babel-tmux-terminal-opts nil))
#+end_src

*** Org Alert
Like life-alert but on Org mode.
#+begin_src elisp :mkdirp yes :tangle ./modules/org.el
(use-package org-alert
  :after org
  :config
  (run-with-timer 0 (* 5 60) 'org-alert-enable)
  (setq alert-default-style 'libnotify
        org-alert-interval 100
        org-alert-notify-cutoff 15
        org-alert-after-event-cutoff 15))
#+end_src

* Media
Integrate EMMS & Elfeed to play YouTube videos from RSS.
** EMMS (Music, Movies)
EMMS is the best multimedia system available for Emacs.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
(use-package emms-info-mediainfo :after emms)
(use-package emms
  :after general
  :init
  (emms-all)
  (emms-default-players)

  :hook
  (emms-playlist-cleared . emms-player-mpd-clear)
  (emms-browser-mode . visual-line-mode)

  :config
  (general-def
    :keymaps 'override
    :states '(normal visual)
    :prefix "SPC"
    :global-prefix "M-SPC"
    "m" '(:which-key "EMMS")
    "m m" '(emms :which-key "Playlist Buffer")
    "m b" '(emms-smart-browse :which "Smart Browse")
    "m SPC" '(emms-pause :which-key "Pause Playback")
    "m h" '(emms-seek-backward :which-key "Seek 5 Seconds Back")
    "m l" '(emms-seek-forward :which-key "Seek 5 Seconds Forward")
    "m /" '(emms-seek-to :which-key "Seek Specific Point"))
  (setq emms-browser-covers 'emms-browser-cache-thumbnail
        emms-browser-thumbnail-directory '(expand-file-name "thumbnails" "~/.cache/emms/")
        emms-seek-seconds 5
        emms-info-asynchronously t
        emms-player-list '(emms-player-mpd emms-player-mpv)
        emms-info-functions '(emms-info-mpd emms-info-mediainfo)
#+end_src

*** MPD
EMMS can integrate with MPD pretty well.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
        emms-player-mpd-server-name "0.0.0.0"
        emms-player-mpd-server-port "6601"
        mpc-host "0.0.0.0:6601"
        emms-browser-covers 'emms-browser-cache-thumbnail
        emms-browser-thumbnail-directory "~/.cache/emms/thumbnails/")
  (emms-player-mpd-connect)
  (emms-player-mpd-update-all-reset-cache)
  (emms-player-set emms-player-mpd
                   'regex
                   (emms-player-simple-regexp
                    "mp3" "opus" "ogg" "flac" "wav" "m4a"))
  (general-def
    :keymaps 'override
    :states '(normal visual)
    :prefix "SPC"
    :global-prefix "M-SPC"
    "m H" '(emms-player-mpd-previous :which-key "Prev Song")
    "m L" '(emms-player-mpd-next :which-key "Next Song")
    "m +" '(mpc-volup :which-key "Volume +5")
    "m -" '(mpc-voldown :which-key "Volume -5"))

  (defun mpc-volup ()
    (interactive)
    (let* ((mpd_host emms-player-mpd-server-name)
           (mpd_port emms-player-mpd-server-port)
           (mpd_hostport (concat "mpc --host=" mpd_host " --port=" mpd_port)))
      (if (string-equal (shell-command-to-string mpd_hostport)  "MPD error: Connection refused
")
          (message "%s" "MPD not connected")
        (message "%s" (replace-regexp-in-string "\n" "" (format "%s" (shell-command-to-string (concat mpd_hostport " volume +5 | awk 'NR==3 { print $1\" \"$2 }' | sed 's/v/V/g'"))))))))

  (defun mpc-voldown ()
    (interactive)
    (let* ((mpd_host emms-player-mpd-server-name)
           (mpd_port emms-player-mpd-server-port)
           (mpd_hostport (concat "mpc --host=" mpd_host " --port=" mpd_port)))
      (if (string-equal (shell-command-to-string mpd_hostport)  "MPD error: Connection refused
")
          (message "%s" "MPD not connected")
        (message "%s" (replace-regexp-in-string "\n" "" (format "%s" (shell-command-to-string (concat mpd_hostport " volume -5 | awk 'NR==3 { print $1\" \"$2 }' | sed 's/v/V/g'"))))))))
#+end_src

*** MPV
EMMS can also play videos with MPV.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
  (emms-player-set emms-player-mpv
                   'regex
                   (rx (or (: "https://" (* nonl) "youtube.com" (* nonl))
                           (+ (? (or "https://" "http://"))
                              (* nonl)
                              (regexp (eval (emms-player-simple-regexp
                                             "mp4" "mov" "wmv" "avi" "webm" "flv" "mkv")))))))
  (defvar yt-video-quality "1440p")
  (defun t3mpt0n/emms-player-mpv-parameters ()
    (let* ((res yt-video-quality)
           (epmdp emms-player-mpv-parameters)
           (res2 (replace-regexp-in-string "\\b[0-9]+\\b" "\\0" res)))
      (setq emms-player-mpv-parameters `(,@epmdp ,(format "--ytdl-format=bestvideo[height<=%s]+bestaudio/best" res2)))))

  (defun t3mpt0n/yt-res-select ()
    (interactive)
    (let ((availres '("480p" "720p" "1080p" "1440p" "2160p")))
      (ivy-read "ï…ª  Select Video Quality: " availres
                :action (lambda (quality)
                          (setq yt-video-quality quality)))))

  (defun t3mpt0n/get-yt-url (link)
    (let ((watch-id (cadr
                     (assoc "watch?v"
                            (url-parse-query-string
                             (substring
                              (url-filename
                               (url-generic-parse-url link))
                              1))))))
      (concat "https://www.youtube.com/watch?v=" watch-id)))

  (defun t3mpt0n/emms-cleanup-urls ()
    (interactive)
    (let ((keys-to-delete '()))
      (maphash (lambda (key value)
                 (when (eq (cdr (assoc 'type value)) 'url)
                   (add-to-list 'keys-to-delete key)))
               emms-cache-db)
      (dolist (key keys-to-delete)
        (remhash key emms-cache-db)))
    (setq emms-cache-dirty t))

  (t3mpt0n/emms-player-mpv-parameters))

#+end_src

** Elfeed (RSS)
Elfeed is a great RSS reader for Emacs.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
(use-package elfeed
  :after emms
  :hook (elfeed-show-mode . visual-line-mode)
  :config
  (advice-add #'elfeed-insert-html
              :around
              (lambda (fun &rest r)
                (let ((shr-use-fonts nil))
                  (apply fun r))))
  (setq elfeed-enclosure-default-dir (expand-file-name "~/Downloads"))
  (setq-default elfeed-search-filter "@2-weeks-ago -read +unread -junk")
  (evil-define-key 'normal elfeed-show-mode-map
    (kbd "J") 'elfeed-goodies/split-show-next
    (kbd "K") 'elfeed-goodies/split-show-prev
    (kbd "RET") 'elfeed-search-show-entry
    (kbd "q") 'elfeed-search-quit-window
    (kbd "Q") 'elfeed-kill-buffer
    (kbd "u") 'elfeed-update
    (kbd "P") 't3mpt0n/elfeed-play-emms-youtube
    (kbd "+") 't3mpt0n/elfeed-add-emms-youtube)
  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "J") 'elfeed-goodies/split-show-next
    (kbd "K") 'elfeed-goodies/split-show-prev
    (kbd "RET") 'elfeed-search-show-entry
    (kbd "q") 'elfeed-search-quit-window
    (kbd "Q") 'elfeed-kill-buffer
    (kbd "u") 'elfeed-update)

  (defun t3mpt0n/elfeed-add-emms-youtube ()
    (interactive)
    (emms-add-elfeed elfeed-show-entry)
    (elfeed-tag elfeed-show-entry 'watched)
    (elfeed-show-refresh))

  (defun t3mpt0n/elfeed-play-emms-youtube ()
    (interactive)
    (emms-play-elfeed elfeed-show-entry)
    (elfeed-tag elfeed-show-entry 'watched)
    (elfeed-show-refresh))

  (with-eval-after-load 'emms
    (define-emms-source elfeed (entry)
                        (let ((track (emms-track
                                      'url (t3mpt0n/get-yt-url (elfeed-entry-link entry)))))
                          (emms-track-set track 'info-title (elfeed-entry-title entry))
                          (emms-playlist-insert-track track)))))
#+end_src

*** Goodies
Various minor enhancements to Elfeed.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
(use-package elfeed-goodies
  :after elfeed
  :init
  (elfeed-goodies/setup)

  :config
  (setq elfeed-goodies/entry-pane-size 0.5))
#+end_src


*** Feeds
**** Feeds in an Org File
Configure all my feeds in an Org file.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
(use-package elfeed-org
  :after elfeed
  :init
  (elfeed-org)

  :config
  (setq rmh-elfeed-org-files (list (expand-file-name "FEEDS.org" user-emacs-directory) (expand-file-name "Org/FEEDS.org" "~/Docs/"))))
#+end_src

**** Auto Tagging
Auto tag all my feed files.
#+begin_src elisp :mkdirp yes :tangle ./modules/media.el
(use-package elfeed-autotag
  :after elfeed
  :init
  (elfeed-autotag)
  (elfeed-apply-hooks-now)

  :config
  (setq elfeed-autotag-files rmh-elfeed-org-files))
#+end_src

* Programming
** Code Completion (Enabling Company)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package company
  :init
  (global-company-mode)

  :config
  (push 'company-files company-backends)
  (define-key company-mode-map [remap indent-for-tab-command] #'company-indent-or-complete-common))
#+end_src

** Syntax Highlighting (Tree Sitter)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package tree-sitter
  :init (global-tree-sitter-mode))

(use-package tree-sitter-langs :after tree-sitter)
(use-package tree-sitter-indent :after tree-sitter)
#+end_src

** Error Checking (Enabling Flycheck)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package flycheck
  :init
  (global-flycheck-mode))

(use-package flycheck-color-mode-line
  :after flycheck
  :hook (flycheck-mode . flycheck-color-mode-line-mode))
(use-package flycheck-pos-tip :after flycheck)
#+end_src

** MaGit (Git Interface)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package magit
  :after general
  :config
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "g" '(:which-key "Magit")
    "g S" '(magit-status :which-key "Magit Status")
    "g s" '(:which-key "Staging")
    "g s f" '(magit-stage-file :which-key "Stage Current File")
    "g b" '(:which-key "Branch")
    "g b c" '(magit-branch-create :which-key "Create")
    "g b d" '(magit-branch-delete :which-key "Delete")
    "g c" '(magit-commit :which-key "Commit")))
#+end_src

** Parantheses (Smartparens)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package smartparens
  :init
  (smartparens-global-mode 1)
  (show-smartparens-global-mode 1))

(use-package rainbow-delimiters ;; Colorful Parantheses
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Code Snippets (YASnippet)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package yasnippet
  :config
  (setq yas-snippet-dirs '("~/Docs/YASnippet/snippets"))
  (yas-global-mode 1))
#+end_src

** Language Configurations (Eglot)
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package eglot
  :hook
  (prog-mode . lunarix-mode)
  (prog-mode . disable-tabs)
  (prog-mode . t3mpt0n/prog-mode/customligs)
  (eglot--managed-mode . (lambda () (flymake-mode -1)))

  :config
  (setq debug-on-error t
        eglot-workspace-configuration '())

  :custom (defalias 'eglot--major-mode 'eglot--major-modes))
#+end_src

The code below just imports all the LSP files:
#+begin_src nix :mkdirp yes :tangle ./lsp/default.nix
{
  ...
}: {
  imports = [
    ./bls.nix
    ./crystal.nix
    ./jedi.nix
    ./nil.nix
    ./ruby.nix
    ./typst.nix
  ];
}
#+end_src

Below is a comprehensive configuration of all the languages I currently use:
*** Nix
**** [[https://github.com/oxalica/nil][NIL]]
Add this to your =flake.nix= [NOTE: this block is not tangled]:
#+begin_src nix
inputs.nil = {
  url = "github:oxalica/nil";
  inputs.nixpkgs.follows = "nixpkgs";
}
#+end_src

And then install it:
#+begin_src nix :mkdirp yes :tangle ./lsp/nil.nix
{
  pkgs,
  lib,
  inputs,
  ...
}: {
  nixpkgs.overlays = [ inputs.nil.overlays.default ];
  environment.systemPackages = [
    pkgs.nil
  ];
}
#+end_src

**** Configuration
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package nix-mode
  :mode "\\.nix\\'"
  :interpreter "nix"
  :after (eglot smartparens tree-sitter tree-sitter-langs)
  :hook (nix-mode . eglot-ensure)

  :config
  (push '(nix-mode . ("nil")) eglot-server-programs)
  (setq eglot-workspace-configuration '(list (:nil (:formatting (:command ["nixpkgs-fmt"])
                                                     :nix (:binary "/run/current-system/sw/bin/nix"
                                                           :flake (:autoArchive t
                                                                   :autoEvalInputs t
                                                                   :nixpkgsInputName "nixpkgs")))))))
#+end_src

*** Emacs Lisp
Emacs is its own LSP so just push =company-elisp= to =company-backends= and configure general.
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package emacs
  :after (general company smartparens)
  :elpaca nil
  :config
  (push 'company-elisp company-backends)
  (sp-with-modes 'emacs-lisp-mode
    (sp-local-pair "'" nil :actions nil)
    (sp-local-pair "`" nil :actions nil))
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "e"   '(:which-key "Elisp")
    "e b" '(eval-buffer :which-key "Eval Elisp in Buffer")
    "e d" '(eval-defun :which-key "Eval Defun")
    "e e" '(eval-expression :which-key "Eval Elisp Expression")
    "e l" '(eval-last-sexp :which-key "Eval Last Expression")
    "e r" '(eval-region :which-key "Eval Region")))
#+end_src

*** Shell
**** [[https://github.com/bash-lsp/bash-language-server][Bash Language Server]]
Install bash-language-server to Nix.
#+begin_src nix :mkdirp yes :tangle ./lsp/bls.nix
{
  pkgs,
  ...
}: {
  environment.systemPackages = with pkgs; [
    nodePackages_latest.bash-language-server
  ];
}
#+end_src

**** Configuration
The config's also pretty simple:
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package sh-script
  :elpaca nil
  :after eglot
  :hook
  (sh-mode . eglot-ensure))
#+end_src

*** Python
**** Install [[https://github.com/davidhalter/jedi][Jedi]] && [[https://github.com/pylint-dev/pylint][Pylint]]
 will be our LSP and Pylint will be used for error checking.
#+begin_src nix :mkdirp yes :tangle ./lsp/jedi.nix
{
  pkgs,
  ...
}: {
  environment.systemPackages = with pkgs.python311Packages; [
    jedi
    jedi-language-server
    pylint
  ];
}
#+end_src

**** Initial Setup
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package python-mode
  :after eglot
  :hook
  (python-mode . eglot-ensure)

  :config
  (push '(python-mode . "jedi-language-server") eglot-server-programs))
#+end_src

**** Jedi
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package company-jedi
  :after company
  :init
  (push 'company-jedi company-backends))
#+end_src

*** Ruby
**** Install [[https://github.com/castwide/solargraph][Solargraph]]
#+begin_src nix :mkdirp yes :tangle ./lsp/ruby.nix
{
  pkgs,
  ...
}: {
  environment.systemPackages = with pkgs; [
    (ruby.withPackages (ru: with ru; [
      solargraph
    ]))
    rubocop
  ];
}
#+end_src

**** Configuration
Install robe for better ruby navigation.
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package robe
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :after (eglot company)
  :hook
  (ruby-mode . robe-mode)
  (robe-mode . eglot-ensure)

  :config
  (push 'company-robe company-backends))
#+end_src

*** Crystal
Very similar to Ruby.
**** Install [[https://github.com/crystal-lang/crystal][Crystal]] & [[https://github.com/elbywan/crystalline][Crystalline]]
Crystalline is a currently in development LSP for Crystal.

***** First, we need to make a derivation...
For =src.sha256=, add =lib.fakeSha256= to it and then copy whatever the =got:= section of the error message spat out into it.
#+begin_src nix :mkdirp yes :tangle /etc/nixos/packages/crystalline/default.nix
{
  lib,
  stdenv,
  fetchurl,
  gzip,
  ...
}: stdenv.mkDerivation rec {
  pname = "crystalline";
  version = "0.10.0";
  src = fetchurl {
    url = "https://github.com/elbywan/${pname}/releases/download/v${version}/${pname}_x86_64-unknown-linux-musl.gz";
    sha256 = "sha256-FQhLmcgQJoIj6K1Vf6L0JknTe5lJGTX2F/WTg5Ktqrs=";
  };

  buildInputs = [ gzip ];
  unpackPhase = ''
    cp $src crystalline.gz
    gzip -d crystalline.gz
  '';

  installPhase = ''
    chmod u+x crystalline
    mkdir -p $out/bin
    cp -a crystalline $out/bin
  '';

  meta = with lib; {
    description = "A Language Server Protocol implementation for Crystal. ðŸ”®";
    homepage = "https://github.com/elbywan/crystalline";
    license = licenses.mit;
    platforms = platforms.linux;
    maintainers = with maintainers; [ t3mpt0n ];
  };
}
#+end_src

Then, append this to wherever you call your packages [NOTE: this block is not tangled]:
#+begin_src nix
{
  pkgs,
  ...
}: with pkgs; rec {
  crystalline = callPackage ./wherever_crystalline_deriv_is {};
}
#+end_src

***** Installing the packages
#+begin_src nix :mkdirp yes :tangle ./lsp/crystal.nix
{
  self,
  pkgs,
  lib,
  ...
}: {
  environment.systemPackages = with pkgs; [
    self.outputs.packages.x86_64-linux.crystalline
    crystal
  ];
}
#+end_src

**** Configuration
Now that we have installed both packages let's configure them with eglot:
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package crystal-mode
  :after eglot
  :hook (crystal-mode . eglot-ensure)
  :config (push '(crystal-mode . ("crystalline")) eglot-server-programs))

(use-package flycheck-crystal :after crystal-mode)
(use-package inf-crystal :after crystal-mode)

(use-package ameba
  :after crystal-mode
  :init (flycheck-ameba-setup))
(use-package flycheck-ameba :after ameba)
#+end_src

*** Typst
Rust alternative to LaTeX.
Doesn't that well yet as Typst is a new language.
**** Installing [[https://github.com/typst/typst][Typst]]
#+begin_src nix :mkdirp yes :tangle ./lsp/typst.nix
{
  pkgs,
  ...
}: {
  environment.systemPackages = with pkgs; [
    typst
    typst-lsp
    typst-fmt
  ];
}
#+end_src

**** Configuration
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package typst-ts-mode
  :after (eglot tree-sitter tree-sitter-langs company)
  :mode "\\.typ\\'"
  :interpreter "typst"
  :hook (typst-ts-mode . eglot-ensure)
  :elpaca
  (
   :repo "https://git.sr.ht/~meow_king/typst-ts-mode"
   :branch "main"
   :protocol https
   :main "typst-ts-mode.el"
   :files (:defaults "highlight.compare.scm")
   )

  :config
  (push '(typst "https://github.com/uben0/tree-sitter-typst") treesit-language-source-alist)
  (push '(typst-ts-mode . ("typst-lsp")) eglot-server-programs))
#+end_src

*** Rust
**** Installing [[https://github.com/oxalica/rust-overlay][Rust Overlay]] && Rust Packages
#+begin_src nix :mkdirp yes :tangle ./lsp/rust.nix
{
  self,
  pkgs,
  ...
}: {
  nixpkgs.overlays = [ (import self.inputs.ru-ov.overlays.default) ];
  environment.systemPackages = with pkgs; [
    (rust-bin.stable.latest.default.override {
      extensions = [ "rust-src" ];
    })
    rust-analyzer-unwrapped
  ];
}
#+end_src

**** Configuration
#+begin_src elisp :mkdirp yes :tangle ./modules/prgm.el
(use-package rust-mode)
(use-package rustic
  :mode "\\.rs\\'"
  :after (rust-mode eglot)
  :hook (rustic-mode . eglot-ensure)

  :config
  (add-to-list 'major-mode-remap-alist '(rust-mode . rustic-mode))
  (setq rustic-lsp-client 'eglot))
#+end_src

* Dired
#+begin_src elisp :mkdirp yes :tangle ./modules/dired.el
(use-package dired
  :after (general evil)
  :elpaca nil
  :ensure nil
  :demand nil
  :config
  (setq dired-listing-switches "-agho --group-directories-first"
        dired-recursive-copies 'top
        dired-recursive-deletes 'top
        dired-dwim-target t
        dired-auto-revert-buffer t)
  (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file)
  (evil-define-key 'normal dired-mode-map (kbd "RET") 'dired-open-file)
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "d" '(:which-key "Dired")
    "d d" '(dired :which-key "Open Dired")
    "d j" '(dired-jump :which "Jump to Current Buffer Dir")
    "d p" '(peep-dired :which "Peep Dired")))

  :custom
  (if (< emacs-major-version 28)
      (progn
        (require 'dired-x)
        (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
        (define-key dired-mode-map (kbd "^") (lambda () (interactive) (find-alternate-file ".."))))
    (progn
      (setq dired-kill-when-opening-new-dired-buffer t)))
#+end_src

** Icons for Dired
#+begin_src elisp :mkdirp yes :tangle ./modules/dired.el
(use-package nerd-icons-dired
  :after (dired nerd-icons)
  :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

** Peep Dired
Peep a file in Dired.
#+begin_src elisp :mkdirp yes :tangle ./modules/dired.el
(use-package peep-dired
  :hook (peep-dired . evil-normalize-keymaps)
  :config
  (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file)
  (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file))
#+end_src

** File Compression Programs
#+begin_src elisp :mkdirp yes :tangle ./modules/dired.el
(eval-after-load "dired-aux"
  '(progn
     (add-to-list 'dired-compress-file-suffixes '("\\.zip\\'" ".zip" "unzip %i"))
     (add-to-list 'dired-compress-file-suffixes '("\\.rar\\'" ".rar" "unrar x %i"))))
#+end_src

** Open File Extensions
#+begin_src elisp :mkdirp yes :tangle ./modules/dired.el
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "imv")
                                ("jpg" . "imv")
                                ("jpeg" . "imv")
                                ("png" . "imv")
                                ("mkv" . "mpv")
                                ("mp4" . "mpv")
                                ("mp3" . "mpv")
                                ("m4a" . "mpv")
                                ("ogg" . "mpv")
                                ("opus" . "mpv")
                                ("nes" . "nestopia -f")
                                ("smc" . "ares --system Super Famicom --fullscreen")
                                ("sfc" . "ares --system Super Famicom --fullscreen")
                                ("n64" . "flatpak run --filesystem=host:ro io.github.simple64.simple64 --nogui")
                                ("v64" . "flatpak run --filesystem=host:ro io.github.simple64.simple64 --nogui")
                                ("z64" . "flatpak run --filesystem=host:ro io.github.simple64.simple64 --nogui")
                                ("torrent" . "qbittorrent"))))
#+end_src

* Other Useful Programs
** VTerm
#+begin_src elisp :mkdirp yes :tangle ./modules/other.el
(use-package vterm
  :after general
  :config
  (setq shell-file-name "/run/current-system/sw/bin/fish"
        vterm-max-scrollback 5000)
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "O" '(:which-key "Open Misc. Programs")))

(use-package multi-vterm
  :after vterm
  :config
  (general-def
    :states '(normal visual)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "M-SPC"
    "O v" '(multi-vterm :which-key "Open new Vterm buffer")))
#+end_src

** RecentF
#+begin_src elisp :mkdirp yes :tangle ./modules/other.el
(use-package recentf
  :elpaca nil
  :init
  (recentf-mode))
#+end_src

** Projectile
#+begin_src elisp :mkdirp yes :tangle ./modules/other.el
(use-package projectile
  :init
  (projectile-mode +1)

  :bind (:map projectile-mode-map
    ("C-c p" . projectile-command-map))

  :config
  (setq projectile-sort-order 'recentf
        projectile-enable-caching t
        projectile-file-exists-remote-cache-expire (* 10 60)
        projectile-completion-system 'ivy
        projectile-switch-project-action #'projectile-dired))
#+end_src

* Now, load all the modules!
#+begin_src elisp :mkdirp yes :tangle ./init.el
(progn
  (load "/etc/nixos/emacs/modules/elpaca/config.el")
  (load "/etc/nixos/emacs/modules/UI.el")
  (load "/etc/nixos/emacs/modules/org.el")
  (load "/etc/nixos/emacs/modules/startup.el")
  (load "/etc/nixos/emacs/modules/media.el")
  (load "/etc/nixos/emacs/modules/prgm.el")
  (load "/etc/nixos/emacs/modules/dired.el")
  (load "/etc/nixos/emacs/modules/other.el"))
#+end_src
